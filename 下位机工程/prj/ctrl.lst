C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CTRL
OBJECT MODULE PLACED IN .\ctrl.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\code\ctrl.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\ctrl.lst) OBJECT(.\c
                    -trl.obj)

line level    source

   1          #include "include.h"
   2          
   3          const INT8U DefaultKeyABuf[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };//Ä¬ÈÏÃÜÔ¿Êý×é»º³åÇø
   4          
   5          INT8U CardRevBuf[16] = { 0 }; //Êý¾ÝÏÔÊ¾»º³åÇø£¬16space£¬0
   6          INT8U const CardKeyABlockBuf[16] = {  //Êý¾ÝÃÜÔ¿ Êý×é¿é»º³åÇø
   7                                                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   8                                                                          0xff,0x07,0x80,0x69,
   9                                                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     
  10                                                                          };
  11          
  12          INT8U CtrlMode = CTRL_BOARD_MODE;  //¶Á¿¨Æ÷¿ØÖÆÄ£Ê½
  13          INT8U OptMode  = OPT_INC_MODE;  //Ñ¡Ôñ Ä£Ê½
  14          INT8U bPass = 1; bWarn = 0;
  15          INT8U LedOnType = LED_LONG;     //LEDÀàÐÍ£º³¤ÁÁ
  16          INT16U i;
  17          //INT16U flag;
  18          //INT16U count=0;
  19          
  20          int CARDREDUCE = 1;      //Ê±Ð§¿¨È¨ÏÞ¼õÒ»
  21          int CARDADD = 2;        //Ê±Ð§¿¨È¨ÏÞ¼Ó¶þ
  22          
  23          
  24          void pass( void )  //Í¨¹ýÊ±µÄLEDºÍ·äÃùÆ÷µÄ×´Ì¬
  25          {       
  26   1              lcdMsg("Í¨",3,3);
  27   1              P15_ON;
  28   1              //LED_ON;
  29   1              BEEP_ON;
  30   1              delay_ms(2000);
  31   1              P15_OFF;
  32   1              BEEP_OFF;
  33   1              //LED_OFF;
  34   1                      
  35   1      }
  36          
  37          void warn(void)  //²»Í¨Ê±µÄLEDºÍ·äÃùÆ÷µÄ×´Ì¬
  38          {
  39   1              INT8U i;
  40   1              lcdMsg("²»Í¨",3,3);
  41   1              //lcdMsg("¾¯¸æ",1,3);   
  42   1              LED_OFF;
  43   1              for( i = 0; i < 3; i++ )
  44   1              {
  45   2                      LED_ON;
  46   2                      BEEP_ON;
  47   2                      delay_ms(200);
  48   2                      BEEP_OFF;
  49   2                      LED_OFF;
  50   2                      delay_ms(200);
  51   2              }       
  52   1      }
  53          
  54          void alarm(void)         //¾¯¸æÊ±µÄLEDºÍ·äÃùÆ÷µÄ×´Ì¬
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 2   

  55          {
  56   1              //lcdInitinal();
  57   1              //delay_ms(2);
  58   1              INT8U i;
  59   1              lcdMsg("¾¯¸æ",3,3);             
  60   1              LED_OFF;
  61   1              for( i = 0; i < 5; i++ )
  62   1              {
  63   2                      LED_ON;
  64   2                      BEEP_ON;
  65   2                      delay_ms(150);
  66   2                      BEEP_OFF;
  67   2                      LED_OFF;
  68   2                      delay_ms(150);
  69   2              }
  70   1              
  71   1      }
  72          
  73          void cal_keyA( INT8U *DestBuf )  //¼ÆËãÃÜÂëÊý×é
  74          {
  75   1              const INT8U KeyABuf[] = { 0x20, 0x12, 0x10, 0x01, 0x00, 0x00 }; //ÃÜÔ¿
  76   1              memcpy( DestBuf, KeyABuf, 6 ); //°ÑKeyABufµÄÊý×é¿½±´¸øDestBuf
  77   1      }
  78          
  79          void send_rebck( psUartData psUartDataRevSend )   //¶¨Òå psUartData½á¹¹Ìå±äÁ¿psUartDataRevSend
  80          {
  81   1              INT8U * pTmp;
  82   1              INT8U Len,Check;
  83   1              INT8U i;
  84   1      
  85   1              Len = psUartDataRevSend->UartCmdLen     + psUartDataRevSend->UartDataLen + 2;
  86   1              pTmp = ( INT8U * )psUartDataRevSend;
  87   1      
  88   1              send_byte( 0xFC );
  89   1              Check = 0xFC;
  90   1              for( i = 0; i < Len; i++ )
  91   1              {
  92   2                      send_byte( *pTmp );
  93   2                      Check ^= *pTmp++;
  94   2              }
  95   1              send_byte( Check );     
  96   1      }
  97          
  98          void uart_over( void )    //½ÓÊÕÍê³É
  99          {
 100   1              UartCount = 0;
 101   1              UartStart = FALSE;
 102   1              UartComp = FALSE;
 103   1      }
 104          
 105          INT8U check_com( psUartData psUartDataRevSend )   //¼ì²éÃüÁî
 106          {
 107   1              psUartDataRevSend->UartDataBuf[0] = 0xAA;
 108   1      
 109   1              return TRUE;
 110   1      }
 111          
 112          INT8U req_card_sn( psUartData psUartDataRevSend )       //Ñ°¿¨
 113          {
 114   1              if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö½
             -Ú        
 115   1              {
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 3   

 116   2                      if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö
             -½Ú        
 117   2                      {
 118   3                              psUartDataRevSend->UartErrCode = ERROR_NOCARD;
 119   3                              memset( psUartDataRevSend->UartDataBuf, 0x00, psUartDataRevSend->UartDataLen );
 120   3                              bWarn = 1;
 121   3                              return FALSE;
 122   3                      }       
 123   2              }
 124   1              
 125   1              if( PcdAnticoll( &CardRevBuf[2] ) != MI_OK ) //·À³å×²£¬·µ»Ø¿¨µÄÐòÁÐºÅ 4×Ö½Ú 
 126   1              {
 127   2                      psUartDataRevSend->UartErrCode = ERROR_ATCLL;
 128   2                      memset( psUartDataRevSend->UartDataBuf, 0x00, psUartDataRevSend->UartDataLen );
 129   2                      bWarn = 1;
 130   2                      return FALSE;   
 131   2              }
 132   1      
 133   1              memcpy( psUartDataRevSend->UartDataBuf, &CardRevBuf[2], 4 );
 134   1      
 135   1              bPass = 1;
 136   1      
 137   1              return TRUE;
 138   1      }
 139          
 140          INT8U updata_key( psUartData psUartDataRevSend )  //ÐÞ¸ÄÃÜÂë
 141          {
 142   1              INT8U CardKeyABuf[6];
 143   1              INT8U KeyBlockAddr;
 144   1      
 145   1              psUartDataRevSend->UartDataLen = 7;
 146   1              KeyBlockAddr = psUartDataRevSend->UartDataBuf[0];
 147   1      
 148   1              if( KeyBlockAddr % 4 != 3 )
 149   1              {
 150   2                      psUartDataRevSend->UartErrCode = ERROR_BLOCK_ADDR;
 151   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 152   2                      bWarn = 1;
 153   2                      return FALSE;   
 154   2              }
 155   1      
 156   1              if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö½
             -Ú        
 157   1              {
 158   2                      if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö
             -½Ú        
 159   2                      {
 160   3                              psUartDataRevSend->UartErrCode = ERROR_NOCARD;
 161   3                              memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 162   3                              bWarn = 1;
 163   3                              return FALSE;
 164   3                      }       
 165   2              }
 166   1      
 167   1              if( PcdAnticoll( &CardRevBuf[2] ) != MI_OK ) //·À³å×²£¬·µ»Ø¿¨µÄÐòÁÐºÅ 4×Ö½Ú 
 168   1              {
 169   2                      psUartDataRevSend->UartErrCode = ERROR_ATCLL;
 170   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 171   2                      bWarn = 1;
 172   2                      return FALSE;   
 173   2              }
 174   1      
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 4   

 175   1              if( PcdSelect( &CardRevBuf[2] ) != MI_OK )//Ñ¡¿¨
 176   1              {
 177   2                      psUartDataRevSend->UartErrCode = ERROR_SLCT;
 178   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 179   2                      bWarn = 1;
 180   2                      return FALSE;
 181   2              }
 182   1      
 183   1              memcpy( CardKeyABuf, &psUartDataRevSend->UartDataBuf[1], 6 );
 184   1      
 185   1              if( PcdAuthState( PICC_AUTHENT1A, KeyBlockAddr, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 186   1              {
 187   2                      psUartDataRevSend->UartErrCode = ERROR_KEYA_IC;
 188   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 189   2                      bWarn = 1;
 190   2                      return FALSE;   
 191   2              }
 192   1      
 193   1              memcpy( CardKeyABlockBuf, &psUartDataRevSend->UartDataBuf[7], 6 );
 194   1      
 195   1              if( PcdWrite( KeyBlockAddr, CardKeyABlockBuf ) != MI_OK )// Ð´¿¨
 196   1              {
 197   2                      psUartDataRevSend->UartErrCode = ERROR_WRITE_IC;
 198   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 199   2                      bWarn = 1;
 200   2                      return FALSE;
 201   2              }
 202   1      
 203   1              memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 6 );
 204   1              bPass = 1;
 205   1              return TRUE;
 206   1      }
 207          
 208          INT8U block_write( psUartData psUartDataRevSend )       //¿é£¬Ð´
 209          {
 210   1              INT8U CardWriteBuf[16];
 211   1              INT8U CardKeyABuf[6];
 212   1              INT8U KeyBlockAddr;
 213   1      
 214   1              psUartDataRevSend->UartDataLen = 0x11;
 215   1              KeyBlockAddr = psUartDataRevSend->UartDataBuf[0];
 216   1      
 217   1              if( KeyBlockAddr % 4 == 3 )
 218   1              {
 219   2                      psUartDataRevSend->UartErrCode = ERROR_BLOCK_ADDR;
 220   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 221   2                      bWarn = 1;
 222   2                      return FALSE;   
 223   2              }
 224   1      
 225   1              if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö½
             -Ú        
 226   1              {
 227   2                      if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö
             -½Ú        
 228   2                      {
 229   3                              psUartDataRevSend->UartErrCode = ERROR_NOCARD;
 230   3                              memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 231   3                              bWarn = 1;
 232   3                              return FALSE;
 233   3                      }       
 234   2              }
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 5   

 235   1      
 236   1              if( PcdAnticoll( &CardRevBuf[2] ) != MI_OK ) //·À³å×²£¬·µ»Ø¿¨µÄÐòÁÐºÅ 4×Ö½Ú 
 237   1              {
 238   2                      psUartDataRevSend->UartErrCode = ERROR_ATCLL;
 239   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 240   2                      bWarn = 1;
 241   2                      return FALSE;   
 242   2              }
 243   1      
 244   1              if( PcdSelect( &CardRevBuf[2] ) != MI_OK )//Ñ¡¿¨
 245   1              {
 246   2                      psUartDataRevSend->UartErrCode = ERROR_SLCT;
 247   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 248   2                      bWarn = 1;
 249   2                      return FALSE;
 250   2              }
 251   1      
 252   1              memcpy( CardKeyABuf, &psUartDataRevSend->UartDataBuf[1], 6 );
 253   1      
 254   1              if( PcdAuthState( PICC_AUTHENT1A, KeyBlockAddr, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 255   1              {
 256   2                      psUartDataRevSend->UartErrCode = ERROR_KEYA_IC;
 257   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 258   2                      bWarn = 1;
 259   2                      return FALSE;   
 260   2              }
 261   1      
 262   1              memcpy( CardWriteBuf, &psUartDataRevSend->UartDataBuf[7], 16 );
 263   1              if( PcdWrite( KeyBlockAddr, CardWriteBuf ) != MI_OK )//Ð´¿¨
 264   1              {
 265   2                      psUartDataRevSend->UartErrCode = ERROR_WRITE_IC;
 266   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 267   2                      bWarn = 1;
 268   2                      return FALSE;
 269   2              }
 270   1              bPass = 1;
 271   1              
 272   1              return TRUE;
 273   1      }
 274          
 275          INT8U block_read( psUartData psUartDataRevSend )   //¿é£¬¶Á
 276          {
 277   1              INT8U CardReadBuf[16];
 278   1              INT8U CardKeyABuf[6];
 279   1              INT8U KeyBlockAddr;
 280   1      
 281   1              psUartDataRevSend->UartDataLen = 0x11;
 282   1              KeyBlockAddr = psUartDataRevSend->UartDataBuf[0];
 283   1      
 284   1              if( KeyBlockAddr % 4 == 3 )
 285   1              {
 286   2                      psUartDataRevSend->UartErrCode = ERROR_BLOCK_ADDR;
 287   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 288   2                      bWarn = 1;
 289   2                      return FALSE;   
 290   2              }
 291   1      
 292   1              if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö½
             -Ú        
 293   1              {
 294   2                      if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö
             -½Ú        
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 6   

 295   2                      {
 296   3                              psUartDataRevSend->UartErrCode = ERROR_NOCARD;
 297   3                              memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 298   3                              bWarn = 1;
 299   3                              return FALSE;
 300   3                      }       
 301   2              }
 302   1      
 303   1              if( PcdAnticoll( &CardRevBuf[2] ) != MI_OK ) //·À³å×²£¬·µ»Ø¿¨µÄÐòÁÐºÅ 4×Ö½Ú 
 304   1              {
 305   2                      psUartDataRevSend->UartErrCode = ERROR_ATCLL;
 306   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 307   2                      bWarn = 1;
 308   2                      return FALSE;   
 309   2              }
 310   1      
 311   1              if( PcdSelect( &CardRevBuf[2] ) != MI_OK )//Ñ¡¿¨
 312   1              {
 313   2                      psUartDataRevSend->UartErrCode = ERROR_SLCT;
 314   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 315   2                      bWarn = 1;
 316   2                      return FALSE;
 317   2              }
 318   1      
 319   1              memcpy( CardKeyABuf, &psUartDataRevSend->UartDataBuf[1], 6 );
 320   1      
 321   1              if( PcdAuthState( PICC_AUTHENT1A, KeyBlockAddr, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 322   1              {
 323   2                      psUartDataRevSend->UartErrCode = ERROR_KEYA_IC;
 324   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 325   2                      bWarn = 1;
 326   2                      return FALSE;   
 327   2              }
 328   1      
 329   1              if( PcdRead( KeyBlockAddr, CardReadBuf ) != MI_OK )// ¶Á¿¨
 330   1              {
 331   2                      psUartDataRevSend->UartErrCode = ERROR_READ_IC;
 332   2                      memset( &psUartDataRevSend->UartDataBuf[1], 0x00, 16 );
 333   2                      bWarn = 1;
 334   2                      return FALSE;
 335   2              }
 336   1              memcpy( &psUartDataRevSend->UartDataBuf[1], CardReadBuf, 16 );
 337   1              bPass = 1;
 338   1                              
 339   1              return TRUE;
 340   1      }
 341          
 342          void display_error( void )      //³ÌÐò¾¯¸æÊ±µÄÏÔÊ¾×´Ì¬
 343          {               
 344   1              
 345   1                      lcdInitinal();
 346   1                      delay_ms(2);
 347   1                      
 348   1              lcdMsg("·Ç·¨¿¨",1,3);
 349   1                      lcdMsg("¾¯¸æ£¬¾¯¸æ",2,2);
 350   1                      delay_ms(2);
 351   1                      warn();
 352   1                      
 353   1      }
 354          
 355          void display_no_id( void )      //Î´·Å¿¨×´Ì¬
 356          {
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 7   

 357   1          char DisplayBuf[10];          //¶¨ÒåÏÔÊ¾»º³åÇøÊý×é£¬10¸ö¿Õ¼ä£¬Ã¿¸ö¿Õ¼ä´æ·ÅÒ»¸öcharÐÍÊý¾Ý
 358   1          memset(DisplayBuf,0,10);     //³õÊ¼»¯ÏÔÊ¾»º³åÇø
 359   1      
 360   1              switch( OptMode )         //Ñ¡ÔñÄ£Ê½
 361   1              {
 362   2                      case OPT_INC_MODE:         //·Å¿¨£¬¿ª»úÄ¬ÈÏ
 363   2                                                      
 364   2                              lcdInitinal();
 365   2                              delay_ms(2);    
 366   2                  lcdMsg("Çë·Å¿¨",1,2);
 367   2                              lcdMsg("¿¨ºÅ£º",2,0);
 368   2                  lcdMsg("×´Ì¬£º",3,0); 
 369   2      
 370   2                              break;
 371   2      
 372   2                      case OPT_ADD_MODE:         //¼ÓÈ¨
 373   2      
 374   2                              lcdInitinal();
 375   2                  lcdMsg("Ôö¼ÓÈ¨ÏÞ+", 1, 0 );
 376   2                              lcdMsg("¿¨ºÅ£º",2,0);
 377   2                  lcdMsg("×´Ì¬£º",3,0);                                               
 378   2                              
 379   2                              break;
 380   2      
 381   2                      case OPT_READ_MODE:        //¶Á¿¨
 382   2                                                      
 383   2                              lcdInitinal();
 384   2                  lcdMsg("¶Á¿¨Ä£Ê½",1,3);
 385   2                              lcdMsg("¿¨ºÅ:",2,0);
 386   2                  lcdMsg("¶Á¿¨:----",3,0);
 387   2                                                      
 388   2                              break;
 389   2      
 390   2                      case OPT_REG_MODE:       //×¢²á
 391   2                                                      
 392   2                              lcdInitinal();
 393   2                  lcdMsg("×¢²áÄ£Ê½", 1, 3 );
 394   2                              lcdMsg("¿¨ºÅ£º",2,0);
 395   2                  lcdMsg("¿ª¿¨£º----",3,0);
 396   2      
 397   2                              break;
 398   2      
 399   2                      default:
 400   2                              break;
 401   2              }
 402   1      }
 403          
 404          
 405          void display_money( INT32U CardMoney )  //ÏÔÊ¾money..
 406          {
 407   1              char DisplayBuf[10];
 408   1              char *pDisplayChar;
 409   1              INT32U Tmp;
 410   1      
 411   1              pDisplayChar = DisplayBuf;
 412   1      
 413   1              if( CardMoney > 9999 )  //
 414   1              {
 415   2                      CardMoney = 9999;
 416   2              }
 417   1      
 418   1              Tmp = CardMoney;
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 8   

 419   1      
 420   1              *pDisplayChar++ = Tmp / 1000 + '0';
 421   1              Tmp %= 1000;
 422   1              *pDisplayChar++ = Tmp / 100 + '0';
 423   1              Tmp %= 100;
 424   1              *pDisplayChar++ = Tmp / 10 + '0';
 425   1              Tmp %= 10;
 426   1              *pDisplayChar++ = Tmp + '0';
 427   1              *pDisplayChar++ = '\0';           
 428   1      
 429   1       }      
 430          
 431          
 432          void ruce( void )          //
 433          {       
 434   1              INT16U z;       
 435   1              delay_ms(2000);
 436   1      
 437   1              for(z=5;z>0;z--)
 438   1              {               
 439   2                      P16=0;
 440   2                      delay_ms(2000);
 441   2                      P16=1;          
 442   2                      delay_ms(2000);
 443   2              }
 444   1      
 445   1                      if(OptMode = OPT_INC_MODE)
*** WARNING C276 IN LINE 445 OF ..\CODE\CTRL.C: constant in condition expression
 446   1                      {
 447   2                              lcdInitinal();
 448   2                              delay_ms(2);    
 449   2                              lcdMsg("×¢Òâ",1,3);
 450   2                              lcdMsg("ÒÑÈç²ÞÎå·ÖÖÓ",2,0);
 451   2                              lcdMsg("ÇëÁôÒâÀÏÈË×´¿ö",3,0);
 452   2                              delay_ms(3000);
 453   2                              lcdInitinal();
 454   2                              alarm();
 455   2                      }  
 456   1                      else
 457   1                      {
 458   2                              pass();
 459   2                              lcdInitinal();
 460   2                              delay_ms(2);
 461   2                              lcdMsg("ÒÑÀë¿ª",3,3);
 462   2                      }
 463   1      }       
 464          
 465          void display_id( INT8U * SrcBuf )  //·Å¿¨Ê±×´Ì¬
 466          {
 467   1              char DisplayBuf[10];
 468   1              char *pDisplayChar;
 469   1              INT8U Tmp, i;
 470   1              //°Ñ´®¿ÚÊý¾Ý×ª»»³É×Ö·û£¬Ð¡ÓÚ10Êý×Ö±íÊ¾£¬´óÓÚ10Ó¢ÎÄ±íÊ¾
 471   1              pDisplayChar = DisplayBuf;
 472   1      
 473   1              for( i = 0; i < 4; i++ )
 474   1              {
 475   2                      Tmp = ( ( *SrcBuf ) >> 4 ) & 0x0F;      
 476   2                      if( ( Tmp >=0 ) && ( Tmp <= 9 ) )
 477   2                      {
 478   3                              *pDisplayChar ++ = '0' + Tmp;   
 479   3                      }
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 9   

 480   2                      else
 481   2                      {
 482   3                              *pDisplayChar ++ = 'A' + Tmp - 10;
 483   3                      }
 484   2      
 485   2                      Tmp = ( *SrcBuf ) & 0x0F;       
 486   2                      if( ( Tmp >=0 ) && ( Tmp <= 9 ) )
 487   2                      {
 488   3                              *pDisplayChar ++ = '0' + Tmp;   
 489   3                      }
 490   2                      else
 491   2                      {
 492   3                              *pDisplayChar ++ = 'A' + Tmp - 10;
 493   3                      }
 494   2      
 495   2                      SrcBuf ++;
 496   2              }
 497   1              *pDisplayChar ++ = '\0';
 498   1      //      char myBuf=DisplayBuf;
 499   1              //Ê¶±ð²»Í¬ÀàÐÍµÄ¿¨
 500   1              if  (strcmp(DisplayBuf,"6E34F771")==0)
 501   1              {       
 502   2                      switch(OptMode) 
 503   2                      {
 504   3                      case OPT_INC_MODE :
 505   3                              
 506   3                              lcdInitinal();
 507   3                              delay_ms(20);
 508   3                              lcdMsg("ÀÏÈË¿¨",1,3);
 509   3                              lcdMsg("¿¨ºÅ£º",2,0);
 510   3                              lcdMsg(DisplayBuf, 2, 3 );                       
 511   3                      lcdMsg("×´Ì¬£º",3,0);
 512   3                              pass();
 513   3                      //      ff();
 514   3                      //      fflush();//Çå³ý»º´æ
 515   3                      //      strcpy(DisplayBuf,"00000000");
 516   3                      //      flag=1;
 517   3                              lcdInitinal();
 518   3                              delay_ms(2);                    
 519   3                              lcdMsg("Èç²ÞÖÐ",2,2);
 520   3                              lcdMsg("ÇëÉÔºóÔÙË¢¿¨",3,1);
 521   3                              ruce();         
 522   3                      
 523   3                              i=get_key(); 
 524   3                              if(i==2)                
 525   3                               delay_ms(2000);
 526   3                               BEEP_ON;
 527   3                               delay_ms(1000);
 528   3                               BEEP_OFF;
 529   3                              
 530   3      /*              else
 531   3                      lcdMsg("³öÀ´ÁË",3,3);
 532   3                       delay_ms(2000);   */
 533   3                      
 534   3                      break;
 535   3      
 536   3                      default:
 537   3                              lcdInitinal();
 538   3                              delay_ms(20);
 539   3                              lcdMsg("ÀÏÈË¿¨",1,3);
 540   3                              break;
 541   3                              }                                                                       
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 10  

 542   2              }
 543   1      
 544   1              else if(strcmp(DisplayBuf,"BB3F58DF")==0)
 545   1                      {
 546   2                              lcdInitinal();
 547   2                              delay_ms(20);
 548   2                              lcdMsg("ÆÕÍ¨¿¨",1,3);
 549   2                                                      
 550   2                              }
 551   1              else if(strcmp(DisplayBuf,"D23EC3B9")==0)
 552   1                      {
 553   2                              lcdInitinal();
 554   2                              delay_ms(20);
 555   2                              lcdMsg("Ê±Ð§¿¨",1,3);   
 556   2                              
 557   2                              }
 558   1              else
 559   1                      {
 560   2                              lcdInitinal();
 561   2                              delay_ms(20);
 562   2                              lcdMsg("Î´·ÖÀà",1,3);
 563   2                                      
 564   2                              
 565   2                              }             
 566   1                      lcdMsg("¿¨ºÅ£º",2,0);
 567   1                      lcdMsg(DisplayBuf, 2, 3 );                       
 568   1              lcdMsg("×´Ì¬£º",3,0);   
 569   1      
 570   1      }
 571          
 572          
 573          
 574          
 575          INT8U ctrl_by_pc( psUartData psUartDataRevSend )        //PC¿ØÖÆ£¨ÉÏÎ»»ú¿ØÖÆ£©
 576          {
 577   1              psUartDataRevSend = psUartDataRevSend;
 578   1      
 579   1              CtrlMode = CTRL_PC_MODE;        
 580   1              
 581   1              lcdMsg("ÉÏÎ»»ú¿ØÖÆ",1,1);
 582   1              lcdMsg("Ò»Ñ¡Ôñ¿ØÖÆÄ£Ê½",2,0);
 583   1              lcdMsg("¶þ¶ÁÐ´¿¨ÄÚÐÅÏ¢",3,0);
 584   1              delay_ms(5000);
 585   1              lcdInitinal();
 586   1              lcdMsg("ÉÏÎ»»ú¿ØÖÆ",1,1);
 587   1              lcdMsg("×´Ì¬£º",3,0);   
 588   1           
 589   1              return TRUE;    
 590   1      }
 591          
 592          INT8U ctrl_by_board( psUartData psUartDataRevSend )      //¶Á¿¨Æ÷¿ØÖÆ£¨ÏÂÎ»»ú¿ØÖÆ£©
 593          {
 594   1              psUartDataRevSend = psUartDataRevSend;
 595   1      
 596   1              display_no_id();
 597   1              
 598   1              return TRUE;    
 599   1      }
 600          
 601          void pc_process( void )    //PC³ÌÐò
 602          {
 603   1              psUartData psUartDataRevSend;
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 11  

 604   1              INT8U i;
 605   1              INT8U Check = 0xFE;
 606   1              INT8U Len;
 607   1      
 608   1              if( UartComp != TRUE )
 609   1              {
 610   2                      return;
 611   2              }
 612   1      
 613   1              psUartDataRevSend = (psUartData)UartBuf;
 614   1              Len = psUartDataRevSend->UartCmdLen + psUartDataRevSend->UartDataLen + 3;
 615   1      
 616   1              for( i = 0; i < ( Len - 1 ); i ++ )
 617   1              {
 618   2                      Check ^= UartBuf[i];
 619   2              }
 620   1              /*
 621   1              if( Check != UartBuf[Len - 1] )
 622   1              {
 623   1                      psUartDataRevSend->UartErrCode = ERROR_CHECK;
 624   1                      send_rebck( psUartDataRevSend );
 625   1                      uart_over();
 626   1                      return;
 627   1              }
 628   1              */
 629   1              
 630   1              switch( psUartDataRevSend->UartCmd ) //ÃüÁîÑ¡Ôñ
 631   1              {       
 632   2                      case 0x0002:  //¼ì²â´®¿Ú×´Ì¬ -> fe 03 01 c1 c0 er 00 ck,  <- fc 03 01 c1 c0 er aa ck
 633   2                              check_com( psUartDataRevSend );
 634   2                              break;
 635   2                      case 0x0003: //²éÑ¯¿¨ºÅ  ->     fe 03 04 c1 c0 er 00 00 00 00 ck, <- fc 03 04 c1 c0 er sn3 sn2 sn1 sn0 ck
 636   2                              req_card_sn( psUartDataRevSend );
 637   2                              break;
 638   2      
 639   2                      case 0x0110: //ÐÞ¸ÄÃÜÂë·½Ê½0 fe 03 0d c1 c0 er kn o5 o4.. o0 n5 n4.. n0 ck, <-fe 03 07 c1 c0 er kn n5 n4
             -.. n0 ck        
 640   2                              updata_key( psUartDataRevSend ); //ÐÞ¸ÄÃÜÂë kn%4 == 3   
 641   2                              break;
 642   2      
 643   2                      case 0x0120: //¶ÁÊý¾Ý¿é·½Ê½0  -> fe 03 07 c1 c0 er kn ky5 ... ky0 ck, <- fc 03 11 c1 c0 er kn d15...d0 c
             -k 
 644   2                              block_read( psUartDataRevSend ); //¶ÁÊý¾Ý¿é kn%4 != 3   
 645   2                              break;
 646   2      
 647   2                      case 0x0130: //Ð´Êý¾Ý¿é·½Ê½0  -> fe 03 07 c1 c0 er kn ky5 ... ky0 ck, <- fc 03 11 c1 c0 er kn d15...d0 c
             -k 
 648   2                              block_write( psUartDataRevSend ); //¶ÁÊý¾Ý¿é kn%4 != 3  
 649   2                              break;
 650   2      
 651   2                      case 0x0140: //°å×Ó¿ØÖÆ
 652   2                              ctrl_by_board( psUartDataRevSend ); //¶ÁÊý¾Ý¿é kn%4 != 3        
 653   2                              break;  
 654   2                              
 655   2                      default:
 656   2                              psUartDataRevSend->UartErrCode = ERROR_NOCMD;   
 657   2                              break;
 658   2              }
 659   1              send_rebck( psUartDataRevSend );
 660   1              uart_over();
 661   1      }
 662          
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 12  

 663          INT8U board_uart_event( void )   //UART½ÓÊÕ
 664          {
 665   1              psUartData psUartDataRevSend;
 666   1              INT8U i;
 667   1              INT8U Check = 0xFE;
 668   1              INT8U Len;
 669   1              INT8U Result = FALSE;
 670   1      
 671   1              if( UartComp != TRUE )
 672   1              {
 673   2                      return Result;
 674   2              }
 675   1      
 676   1              psUartDataRevSend = (psUartData)UartBuf;
 677   1              Len = psUartDataRevSend->UartCmdLen + psUartDataRevSend->UartDataLen + 3;
 678   1      
 679   1              for( i = 0; i < ( Len - 1 ); i ++ )
 680   1              {
 681   2                      Check ^= UartBuf[i];
 682   2              }
 683   1              /*
 684   1              if( Check != UartBuf[Len - 1] )
 685   1              {
 686   1                      psUartDataRevSend->UartErrCode = ERROR_CHECK;
 687   1                      send_rebck( psUartDataRevSend );
 688   1                      uart_over();
 689   1                      return;
 690   1              }
 691   1              */
 692   1              
 693   1              switch( psUartDataRevSend->UartCmd )
 694   1              {       
 695   2                      case 0x0141:  //PC¿ØÖÆ
 696   2                              ctrl_by_pc( psUartDataRevSend );
 697   2                              Result = TRUE;
 698   2                              break;
 699   2                              
 700   2                      default:
 701   2                              psUartDataRevSend->UartErrCode = ERROR_NOCMD;   
 702   2                              break;
 703   2              }
 704   1              send_rebck( psUartDataRevSend );
 705   1              uart_over();
 706   1      
 707   1              return Result;
 708   1      }
 709          
 710          void board_process( void ) //¶Á¿¨Æ÷³ÌÐò
 711          {
 712   1              INT8U CardReadBuf[16];
 713   1              INT8U CardWriteBuf[16];
 714   1              INT8U CardKeyABuf[6];
 715   1              INT32U CardMoney;
 716   1              INT8U KeyVal;
 717   1      
 718   1      
 719   1              if( board_uart_event() == TRUE )   //¶Á¿¨Æ÷¿ØÖÆ
 720   1              {
 721   2                      return;
 722   2              }
 723   1      
 724   1              //¶¨Òå°´¼ü¹¦ÄÜ
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 13  

 725   1              KeyVal = get_key();     
 726   1              switch( KeyVal )
 727   1              {
 728   2                      case KEY_1:             //·Å¿¨¼ü£¬Ä¬ÈÏ
 729   2      
 730   2                              lcdInitinal();          
 731   2                              OptMode = OPT_INC_MODE;         
 732   2                  lcdMsg("Çë·Å¿¨", 1, 0 );
 733   2                              lcdMsg("¿¨ºÅ£º",2,0);
 734   2                              lcdMsg("×´Ì¬£º",3,0);                   
 735   2                              break;
 736   2      
 737   2                      case KEY_2:        //¼ÓÈ¨¼ü
 738   2      
 739   2                              lcdInitinal();          
 740   2                              OptMode = OPT_ADD_MODE;                 
 741   2                  lcdMsg("Ôö¼ÓÈ¨ÏÞ+",1,0);
 742   2                              lcdMsg("¿¨ºÅ£º",2,0);
 743   2                              lcdMsg("×´Ì¬£º",3,0);           
 744   2                              break;
 745   2      
 746   2                      case KEY_3:             //¶Á¿¨¼ü
 747   2      
 748   2                              lcdInitinal();                  
 749   2                              OptMode = OPT_READ_MODE;                        
 750   2                  lcdMsg("¶Á¿¨Ä£Ê½", 1, 3 );  
 751   2                              lcdMsg("¿¨ºÅ£º",2,0);
 752   2                              lcdMsg("×´Ì¬£º",3,0);
 753   2                              break;
 754   2      
 755   2                      case KEY_4:              //×¢²á¼ü
 756   2      
 757   2                              lcdInitinal();          
 758   2                              OptMode = OPT_REG_MODE;                 
 759   2                  lcdMsg("×¢²áÄ£Ê½", 1, 3 );
 760   2                              lcdMsg("¿¨ºÅ£º",2,0);
 761   2                              lcdMsg("×´Ì¬£º",3,0);
 762   2                              break;
 763   2      
 764   2                      default:
 765   2                              break;
 766   2              }
 767   1      
 768   1      
 769   1              if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö½
             -Ú        
 770   1              {
 771   2                      if( PcdRequest( PICC_REQIDL, &CardRevBuf[0] ) != MI_OK )//Ñ°ÌìÏßÇøÄÚÎ´½øÈëÐÝÃß×´Ì¬µÄ¿¨£¬·µ»Ø¿¨Æ¬ÀàÐÍ 2×Ö
             -½Ú        
 772   2                      {
 773   3                              display_no_id();
 774   3                              return;
 775   3                      }       
 776   2              }
 777   1      
 778   1              if( PcdAnticoll( &CardRevBuf[2] ) != MI_OK ) //·À³å×²£¬·µ»Ø¿¨µÄÐòÁÐºÅ 4×Ö½Ú 
 779   1              {
 780   2                      display_no_id();
 781   2                      return; 
 782   2              }
 783   1      
 784   1              if( PcdSelect( &CardRevBuf[2] ) != MI_OK )//Ñ¡¿¨
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 14  

 785   1              {
 786   2                      display_no_id();
 787   2                      return;
 788   2              }
 789   1              display_id( &CardRevBuf[2] );
 790   1      
 791   1              cal_keyA( CardKeyABuf );                //¼ÆËãÃÜÂë
 792   1        //ÎªÑ¡ÔñÄ£Ê½£¬¼´Ã¿¸ö°´¼ü¶¨Òåº¯Êý
 793   1              switch( OptMode )
 794   1              {
 795   2                      case OPT_REG_MODE:                      //ÐÂ¿¨×¢²á
 796   2                              if( PcdAuthState( PICC_AUTHENT1A, 4, DefaultKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 797   2                              {
 798   3                                      alarm();        
 799   3                                      return; 
 800   3                              }
 801   2                              memset( CardWriteBuf, 0, 16 );
 802   2                              if( PcdWrite( 4, CardWriteBuf ) != MI_OK )// Ð´¿¨
 803   2                              {
 804   3                                      alarm();
 805   3                                      return; 
 806   3                              }
 807   2                              memcpy( CardWriteBuf, CardKeyABlockBuf, 16 );
 808   2                              memcpy( CardWriteBuf, CardKeyABuf, 6 );
 809   2                              if( PcdWrite( 7, CardWriteBuf ) != MI_OK )// ÐÞ¸ÄÃÜÂë
 810   2                              {
 811   3                                      alarm();
 812   3                                      return; 
 813   3                              }
 814   2                              lcdMsg("×¢²á³É¹¦", 1, 3);
 815   2                              bPass = 1;
 816   2                              break;
 817   2                                      
 818   2                      case OPT_ADD_MODE:              // ¼ÓÈ¨
 819   2                              if( PcdAuthState( PICC_AUTHENT1A, 4, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 820   2                              {
 821   3                                      alarm();
 822   3                                      return; 
 823   3                              }
 824   2                              if( PcdRead( 4, CardReadBuf ) != MI_OK )// ¶ÁÊý¾Ý
 825   2                              {
 826   3                                      alarm();
 827   3                                      return; 
 828   3                              }
 829   2                              memcpy( ( INT8U * )&CardMoney, CardReadBuf, 4 ); 
 830   2                              CardMoney += CARDADD;                   //
 831   2                              memset( CardWriteBuf, 0, 16 );
 832   2                              memcpy( CardWriteBuf, ( INT8U * )&CardMoney, 4 ); 
 833   2                              if( PcdWrite( 4, CardWriteBuf ) != MI_OK )// Ð´Êý¾Ý
 834   2                              {
 835   3                                      alarm();
 836   3                                      return; 
 837   3                              }
 838   2                              display_money( CardMoney );
 839   2                              bPass = 1;
 840   2                              break;
 841   2                              
 842   2                      case OPT_INC_MODE:              //·Å¿¨
 843   2                              if( PcdAuthState( PICC_AUTHENT1A, 4, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 844   2                              {
 845   3                                      display_error();
 846   3                                      return; 
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 15  

 847   3                              }
 848   2                              if( PcdRead( 4, CardReadBuf ) != MI_OK )// ¶ÁÊý¾Ý
 849   2                              {
 850   3                                      display_error();
 851   3                                      return; 
 852   3                              }
 853   2                              memcpy( ( INT8U * )&CardMoney, CardReadBuf, 4 ); 
 854   2                              if( CardMoney == 0 )             //
 855   2                              {
 856   3                                      display_error();
 857   3                                      bWarn = 1;
 858   3                                      return;
 859   3                              }
 860   2                  CardMoney -= CARDREDUCE;    // 
 861   2                              memset( CardWriteBuf, 0, 16 );
 862   2                              memcpy( CardWriteBuf, ( INT8U * )&CardMoney, 4 ); 
 863   2                              if( PcdWrite( 4, CardWriteBuf ) != MI_OK )// Ð´Êý¾Ý
 864   2                              {
 865   3                                      display_error();
 866   3                                      return; 
 867   3                              }
 868   2                              display_money( CardMoney );
 869   2                              bPass = 1;
 870   2                              break;  
 871   2                              
 872   2                      case OPT_READ_MODE:             //¶Á¿¨
 873   2                              if( PcdAuthState( PICC_AUTHENT1A, 4, CardKeyABuf, &CardRevBuf[2] ) != MI_OK )// ÑéÖ¤ÃÜÂë
 874   2                              {
 875   3                                      display_error();
 876   3                                      return; 
 877   3                              }
 878   2                              if( PcdRead( 4, CardReadBuf ) != MI_OK )// ¶ÁÊý¾Ý
 879   2                              {
 880   3                                      alarm();
 881   3                                      return; 
 882   3                              }
 883   2                              memcpy( ( INT8U * )&CardMoney, CardReadBuf, 4 ); 
 884   2                              display_money( CardMoney );
 885   2                              bPass = 1;
 886   2                              break;                                                                                                 
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                                                                                                                        
             -                 
 887   2                              
 888   2                      default:
 889   2                              break;
 890   2              }
 891   1              PcdHalt();      
 892   1      }
 893          
 894          void ctrl_process( void )  //Ñ¡Ôñ¿ØÖÆÄ£Ê½£¬PC¿ØÖÆ»ò¶Á¿¨Æ÷¿ØÖÆ£¨ÉÏÎ»»ú»òÏÂÎ»»ú£©
 895          {
 896   1      
 897   1              if( CtrlMode == CTRL_PC_MODE )
 898   1              {
 899   2                      pc_process();
 900   2              }
 901   1              else if( CtrlMode == CTRL_BOARD_MODE )
 902   1              {
 903   2                      board_process();
C51 COMPILER V9.00   CTRL                                                                  05/22/2019 22:12:55 PAGE 16  

 904   2              }
 905   1      
 906   1              if( bPass )
 907   1              {
 908   2                      bPass = 0;
 909   2                      pass(); 
 910   2      
 911   2              }
 912   1              if( bWarn )
 913   1              {
 914   2                      bWarn = 0;
 915   2                      warn();
 916   2              }
 917   1      }
 918          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4304    ----
   CONSTANT SIZE    =    278    ----
   XDATA SIZE       =     50     181
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
